<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Hung Nguyen">
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Lớp và đối tượng - Lập trình hướng đối tượng</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/django.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Lập trình hướng đối tượng</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Các chủ đề <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../overview/" class="dropdown-item">Tổng quan về lập trình hướng đối tượng</a>
</li>
                                    
<li>
    <a href="../dotnet-and-csharp/" class="dropdown-item">Nền tảng .NET và ngôn ngữ C#</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Lớp và đối tượng</a>
</li>
                                    
<li>
    <a href="../inheritance/" class="dropdown-item">Thừa kế</a>
</li>
                                    
<li>
    <a href="../polymorphism/" class="dropdown-item">Đa hình</a>
</li>
                                    
<li>
    <a href="../gui-development/" class="dropdown-item">Phát triển ứng dụng GUI với .NET và C#</a>
</li>
                                    
<li>
    <a href="../../labs/" class="dropdown-item">Thực hành</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../author/about/" class="nav-link">Giảng viên</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../dotnet-and-csharp/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../inheritance/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/nd-hung/oop/tree/main/docs/topics/classes-and-objects/README.md" class="nav-link"><i class="fa fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#lop-va-oi-tuong" class="nav-link">Lớp và đối tượng</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#cai-at-lop" class="nav-link">Cài đặt lớp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#thiet-lap-tinh-bao-ong" class="nav-link">Thiết lập tính bao đóng</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#tao-su-dung-va-huy-oi-tuong" class="nav-link">Tạo, sử dụng và hủy đối tượng</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ham-thiet-lap-constructor" class="nav-link">Hàm thiết lập (constructor)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ham-huy-destructorfinalizer" class="nav-link">Hàm hủy (destructor/finalizer)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#lop-tinh-thanh-phan-tinh" class="nav-link">Lớp tĩnh, thành phần tĩnh</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#con-tro-this" class="nav-link">Con trỏ this</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#danh-sach-oi-tuong" class="nav-link">Danh sách đối tượng</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#nap-chong-phuong-thuc-method-overloading" class="nav-link">Nạp chồng phương thức (method overloading)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#nap-chong-toan-tu-operator-overloading" class="nav-link">Nạp chồng toán tử (operator overloading)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="lop-va-oi-tuong">Lớp và đối tượng<a class="headerlink" href="#lop-va-oi-tuong" title="Permanent link">&para;</a></h1>
<p>Classes and Objects</p>
<hr />
<p>Hai khái niệm cơ bản của lập trình hướng đối tượng là lớp và đối tượng. Phần này tóm lược kỹ thuật cài đặt và sử dụng lớp và đối tượng với C#.</p>
<h2 id="cai-at-lop">Cài đặt lớp<a class="headerlink" href="#cai-at-lop" title="Permanent link">&para;</a></h2>
<ul>
<li>Cú pháp</li>
</ul>
<pre><code class="language-csharp">[Thuộc tính truy cập] class &lt;Tên lớp&gt;
{
    // Khai báo các thuộc tính và phương thức
}
</code></pre>
<h2 id="thiet-lap-tinh-bao-ong">Thiết lập tính bao đóng<a class="headerlink" href="#thiet-lap-tinh-bao-ong" title="Permanent link">&para;</a></h2>
<p>Thuộc tính truy cập (access modifier) thể hiện mức độ che chắn đến lớp và các thành viên của lớp.</p>
<p><strong>public</strong>: Mức độ này cho phép truy cập đến lớp hoặc thành viên của lớp (thuộc tính, phương thức) trong cùng một assembly (là tập hợp các khai báo và tài nguyên tạo thành một file thi hành được (.exe hoặc .dll)), hoặc từ một assembly khác tham chiếu đến nó.</p>
<p>Khi một thành viên của lớp có thuộc tính truy cập là public thì mức độ truy cập đến thành viên đó được xác định bằng thuộc tính truy cập của lớp.</p>
<p>Ví dụ:</p>
<pre><code class="language-cs">// Khai báo lớp mô tả loài chó
public class Dog
{
    public string Name;
}

// Chương trình chính
class Program
{
    static void Main(string[] args)
    {
        // Tạo đối tượng của lớp
        Dog dog = new Dog();
        // Thay đổi giá trị thuộc tính
        dog.Name = &quot;Cau Vang&quot;;
        // Đọc thuộc tính
        Console.WriteLine(&quot;The dog's name is &quot; + dog.Name);
    }
}
</code></pre>
<p>Trong đoạn code trên, lớp <code>Dog</code> được khai báo là <code>public</code>, thuộc tính <code>Name</code> cũng được khai báo <code>public</code>. Vì thế, các dòng lệnh trong lớp <code>Program</code> có thể sử dụng lớp <code>Dog</code> và có toàn quyền truy cập (đọc/ghi) đến thuộc tính <code>Name</code>.</p>
<ul>
<li><strong>private</strong>: Chỉ có thể truy xuất đến lớp và thành viên của lớp từ bên trong lớp đó.</li>
</ul>
<p>Trong ví dụ trên, nếu đổi mức độ truy cập của lớp <code>Dog</code> thành <code>private</code> thì khi biên dịch, lệnh <code>Dog dog = new Dog()</code> sẽ báo lỗi là <code>'Dog' is inaccessible due to its protection level</code> và lệnh <code>dog.Name = "Cau Vang"</code> sẽ báo lỗi <code>Dog.Name' is inaccessible due to its protection level</code>.</p>
<p>Nếu đổi mức độ truy cập của lớp <code>Dog</code> thành <code>public</code> và của thuộc tính <code>Name</code> thành <code>private</code> thì khi biên dịch, lệnh <code>Dog dog = new Dog()</code> hợp lệ, nhưng lệnh <code>dog.Name = "Cau Vang"</code> sẽ báo lỗi <code>'Dog.Name' is inaccessible due to its protection level</code>.</p>
<ul>
<li>
<p><strong>protected</strong>: Có thể truy xuất đến lớp và thành viên của lớp từ bên trong lớp đó hoặc từ lớp thừa kế nó.</p>
</li>
<li>
<p><strong>internal</strong>: Chỉ có thể truy xuất đến lớp và thành viên của lớp từ bên trong một assembly.</p>
</li>
<li>
<p><strong>protected internal</strong>: Có thể truy xuất đến lớp và thành viên của lớp từ bên trong assembly, hoặc từ một lớp thừa kế nó nằm trong một assembly khác.</p>
</li>
<li>
<p><strong>private protected</strong>: Chỉ có thể truy xuất đến lớp và thành viên của lớp từ lớp thừa kế trong cùng một assembly.</p>
</li>
</ul>
<h2 id="tao-su-dung-va-huy-oi-tuong">Tạo, sử dụng và hủy đối tượng<a class="headerlink" href="#tao-su-dung-va-huy-oi-tuong" title="Permanent link">&para;</a></h2>
<h3 id="tao-oi-tuong">Tạo đối tượng<a class="headerlink" href="#tao-oi-tuong" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>Cần tạo đối tượng trước khi sử dụng.</p>
</li>
<li>
<p>Cú pháp</p>
</li>
</ul>
<pre><code class="language-c#">&lt;Tên lớp&gt; &lt;Tên đối tượng&gt; = new &lt;Tên lớp&gt;([&lt;Các tham số khởi tạo&gt;]);
</code></pre>
<ul>
<li>Có thể xem lớp là kiểu dữ liệu tự định nghĩa, và mỗi đối tượng là một biến thuộc kiểu dữ liệu đó.</li>
<li>Có thể tạo nhiều đối tượng của cùng một lớp, hoặc tạo mảng hoặc tập hợp các đối tượng.</li>
<li>Có thể tạo đối tượng kết hợp với khởi tạo các thuộc tính cho nó. Cần viết các hàm thiết lập (constructor) phù hợp để áp dụng tính năng này.</li>
</ul>
<p>Ví dụ:</p>
<pre><code class="language-c#">Dog vnDog = new Dog();
vnDog.Name = &quot;Cau Vang&quot;;

Dog jpDog = new Dog();
jpDog.Name = &quot;Shiba&quot;;
</code></pre>
<h2 id="ham-thiet-lap-constructor">Hàm thiết lập (constructor)<a class="headerlink" href="#ham-thiet-lap-constructor" title="Permanent link">&para;</a></h2>
<p>Phương thức thiết lập (constructor) là một hàm đặc biệt dùng để khởi tạo đối tượng. Khi một đối tượng được tạo ra, một hàm thiết lập phù hợp sẽ được gọi.</p>
<p>Hàm thiết lập trùng tên lớp, không có kiểu trả về, có thể có các tham số để khởi tạo giá trị cho các thuộc tính của đối tượng, phạm vi truy cập thường là public.</p>
<p>Một lớp có thể có nhiều hàm thiết lập khác nhau.</p>
<ul>
<li>Cú pháp</li>
</ul>
<pre><code class="language-c#">[public] &lt;Tên lớp&gt;([Danh sách tham số])
{
    // Các lệnh khởi tạo giá trị cho đối tượng
}
</code></pre>
<ul>
<li>Ví dụ</li>
</ul>
<pre><code class="language-c#">// Khai báo lớp mô tả xe hơi
public class Car
{
    public string? Manufacturer;    // Tên hãng sản xuất

    // Hàm thiết lập không tham số
    public Car()
    {
        Manufacturer = &quot;Toyota&quot;;
    }

    // Hàm thiết lập có tham số
    public Car(string? mnf = &quot;&quot;)
    {
        Manufacturer = mnf;
    }

    // Hàm in thông tin hãng xe
    public void Print()
    {
        Console.WriteLine(&quot;Manufacturer: &quot; + Manufacturer);

    }
}

// Chương trình chính
class Program
{
    static void Main(string[] args)
    {
        // Tạo đối tượng xe, gọi hàm thiết lập không tham số
        Car car1 = new Car();
        car1.Print();

        // Tạo đối tượng xe, gọi hàm thiết lập có tham số
        Car car2 = new Car(&quot;Ford&quot;);
        car2.Print();
    }
}
</code></pre>
<p><img alt="Kết quả chạy chương trình" src="code/Car/img/run_example.PNG" /></p>
<h2 id="ham-huy-destructorfinalizer">Hàm hủy (destructor/finalizer)<a class="headerlink" href="#ham-huy-destructorfinalizer" title="Permanent link">&para;</a></h2>
<p>Hàm hủy (destructor, trong C# gọi là finalizer) được gọi tự động khi đối tượng bị hủy.
Hàm hủy có chức năng dọn dẹp bộ nhớ, giải phóng tài nguyên.</p>
<p>Hàm hủy trùng tên lớp và có ký tự <code>~</code> ở trước, không có kiểu trả về, không có tham số, không có phạm vi truy cập.</p>
<p>Một lớp chỉ có một hàm hủy duy nhất.</p>
<ul>
<li>Cú pháp</li>
</ul>
<pre><code class="language-c#">~&lt;Tên lớp&gt;()
{
    // Các lệnh của hàm hủy
}
</code></pre>
<blockquote>
<p>Chú ý: NET 5 (gồm cả .NET Core) trở về sau không gọi hàm hủy khi kết thúc ứng dụng. Bạn có thể tạo ứng dụng với .NET Framework để kiểm nghiệm hoạt động của hàm hủy.</p>
</blockquote>
<h2 id="lop-tinh-thanh-phan-tinh">Lớp tĩnh, thành phần tĩnh<a class="headerlink" href="#lop-tinh-thanh-phan-tinh" title="Permanent link">&para;</a></h2>
<h3 id="lop-tinh">Lớp tĩnh<a class="headerlink" href="#lop-tinh" title="Permanent link">&para;</a></h3>
<p>Khác với lớp thường, một lớp tĩnh (static class) không cho phép tạo ra các đối tượng (không thể dùng toán tử <code>new</code> để tạo đối tượng của lớp tĩnh).</p>
<p>Truy xuất thành viên của lớp tĩnh theo cú pháp <code>&lt;Tên lớp&gt;.&lt;Tên thành viên&gt;</code>.</p>
<p>Lớp tĩnh chỉ chứa các thành phần tĩnh.</p>
<p>Không thể sử dụng lớp tĩnh làm lớp cơ sở cho một lớp khác.</p>
<p>Lớp tĩnh phù hợp cho việc cài đặt thư viện các hàm xử lý với dữ liệu vào mà không cần truy xuất đến dữ liệu của lớp.</p>
<p>Ví dụ sau đây sử dụng lớp tĩnh System.Math có sẵn trong thư viện lớp của .NET:</p>
<pre><code class="language-c#">// Tính diện tích hình tròn, sử dụng hằng số PI và hàm lũy thừa Pow từ lớp tĩnh System.Math
double radius = 1.23;
double circleArea = Math.Pow(radius, 2) * Math.PI;
</code></pre>
<ul>
<li>Tạo lớp tĩnh</li>
</ul>
<p><a href="https://github.com/nd-hung/oop/blob/main/docs/topics/classes-and-objects/code/TemperatureConverter/Program.cs">Xem ví dụ trên GitHub</a></p>
<h3 id="thanh-phan-tinh">Thành phần tĩnh<a class="headerlink" href="#thanh-phan-tinh" title="Permanent link">&para;</a></h3>
<p>Một lớp thường có thể chứa các thành phần (thuộc tính, phương thức) tĩnh. Có thể gọi đến thành phần tĩnh của lớp không tĩnh cả khi chưa tạo đối tượng.</p>
<p>Cú pháp truy cập thành viên tĩnh: <code>&lt;Tên_lớp&gt;.&lt;Tên_thành_viên_tĩnh&gt;</code></p>
<p>Chỉ có một bản sao duy nhất của thành phần tĩnh, bất kể có bao nhiêu đối tượng được tạo ra.</p>
<p>Thông thường, thành phần tĩnh được sử dụng để lưu số lượng đối tượng đã được khởi tạo hoặc để lưu trữ một giá trị được chia sẻ chung cho tất cả đối tượng trong lớp.</p>
<p>Ví dụ:</p>
<pre><code class="language-c#">// Minh họa thành phần tĩnh của lớp không tĩnh
public class Dog    // Khai báo lớp mô tả loài chó
{
    public string Name { get; set; }      // Thuộc tính lưu tên loài
    public static int Count = 0;          // Biến tĩnh để chứa tổng số đối tượng (chó) được tạo ra

    public Dog(string name = &quot;&quot;)          // Hàm thiết lập
    {
        Name = name;
        Count++;                          // Mỗi khi một đối tượng được tạo thì tăng số lượng thêm 1
    }
}

// Chương trình chính
class Program
{
    static void Main()
    {
        Dog dog1 = new Dog(&quot;Shiba&quot;);
        Dog dog2 = new Dog(&quot;Poodle&quot;);
        Dog dog3 = new Dog(&quot;Shepherd&quot;);
        // Truy xuất đến thành phần tĩnh theo cú pháp &lt;Tên lớp&gt;.&lt;Tên thành phần tĩnh&gt;
        Console.WriteLine(&quot;Total number of dogs: {0}&quot;, Dog.Count);
    }
}
</code></pre>
<h2 id="con-tro-this">Con trỏ this<a class="headerlink" href="#con-tro-this" title="Permanent link">&para;</a></h2>
<p>Từ khóa <code>this</code> tham chiếu đến đối tượng đang được xử lý.</p>
<p>Từ khóa <code>this</code> thường được dùng để phân biệt các thành phần cùng tên. Ví dụ:</p>
<pre><code class="language-c#">public class NhanVien
{
    private string maNV;
    private string hoTenNV;

    public NhanVien(string maNV, string hoTenNV)
    {
        this.maNV = maNV;
        this.hoTenNV = hoTenNV;
    }
}
</code></pre>
<h2 id="danh-sach-oi-tuong">Danh sách đối tượng<a class="headerlink" href="#danh-sach-oi-tuong" title="Permanent link">&para;</a></h2>
<p>Trong C#, có thể tổ chức danh sách các đối tượng theo hai cách: tĩnh và động.</p>
<h3 id="danh-sach-tinh-array">Danh sách tĩnh (array)<a class="headerlink" href="#danh-sach-tinh-array" title="Permanent link">&para;</a></h3>
<p>Mảng tĩnh là tập số lượng cố định các phần tử cùng kiểu. Kích thước của mảng được xác định lúc khai báo và không thể thay đổi trong thời gian chạy chương trình. Truy xuất đến từng phần tử của mảng thông qua chỉ số (index) bắt đầu từ 0.</p>
<ul>
<li>Tạo mảng</li>
</ul>
<pre><code class="language-c#">&lt;Kiểu dữ liệu&gt;[] &lt;Tên biến mảng&gt; = new &lt;Kiểu dữ liệu&gt;[&lt;Số phần tử&gt;];
</code></pre>
<ul>
<li>Truy xuất phần tử của mảng</li>
</ul>
<pre><code class="language-c#">&lt;Tên biến mảng&gt;[&lt;Chỉ số&gt;];
</code></pre>
<ul>
<li>Ví dụ:</li>
</ul>
<pre><code class="language-c#">// Khai báo mảng số nguyên
int[] numbers = new int[5];
// Tạo mảng các chuỗi
string[] cars = { &quot;Vinfast&quot;, &quot;Toyota&quot;, &quot;Ford&quot;, &quot;Mazda&quot;, &quot;Honda&quot;};
for (int i = 0; i &lt; cars.Length; ++i)
{
    Console.Write(&quot;{0} &quot;, cars[i]);
}

// Tạo mảng các đối tượng thuộc lớp
// Tạo lớp
class Point
{
    // Properties
    public int X{get;}  
    public int Y{get;}

    // Constructor
    public Point(int x=0, int y=0)
    {
        X = x;
        Y = y;
    }
}

// Tạo mảng các đối tượng của lớp 
Point[] myPoints = new Point[] { new Point(1, 2), new Point(3, 4)};

// Truy xuất phần tử của mảng
foreach (Point p in myPoints)
{
    Console.Write(&quot;({0},{1}) &quot;, p.X, p.Y);
}
</code></pre>
<blockquote>
<p>Do mọi lớp của C# đều có lớp cơ sở chung là <code>Object</code>, nên có thể tạo mảng các đối tượng có kiểu khác nhau như sau:</p>
</blockquote>
<pre><code class="language-c#">object[] myObjects = new object[] {69, &quot;Halo&quot;, 1.23};
foreach (var obj in myObjects)
{
    Console.Write(&quot;{0} &quot;, obj );
}
</code></pre>
<h3 id="danh-sach-ong-list">Danh sách động (list)<a class="headerlink" href="#danh-sach-ong-list" title="Permanent link">&para;</a></h3>
<p>Một danh sách là tập các phần tử cùng kiểu, tuy nhiên kích thước của nó có thể thay đổi được trong khi chạy chương trình. Truy xuất đến từng phần tử của mdanh sách thông qua chỉ số (index) bắt đầu từ 0.</p>
<ul>
<li>Tạo danh sách động</li>
</ul>
<pre><code class="language-c#">List&lt;Kiểu dữ liệu&gt; &lt;Biến danh sách&gt; = new List&lt;Kiểu dữ liệu&gt;();
</code></pre>
<ul>
<li>Ví dụ:</li>
</ul>
<pre><code class="language-c#">// Tạo danh sách động các số nguyên
List&lt;int&gt; ints = new List&lt;int&gt;();

// Thêm các phần tử (trong khi chạy chương trình)
ints.Add(1);
ints.Add(3);    
ints.Add(2);
ints.Add(4);
ints.Add(2);

// In danh sách
foreach (int i in ints)
{
    Console.Write(&quot;{0} &quot;, i);
}

// Sắp xếp danh sách tăng dần
ints.Sort();

// In danh sách sau khi sắp xếp                   
foreach (int i in ints)
{
    Console.Write(&quot;{0} &quot;, i);
}
</code></pre>
<h2 id="nap-chong-phuong-thuc-method-overloading">Nạp chồng phương thức (method overloading)<a class="headerlink" href="#nap-chong-phuong-thuc-method-overloading" title="Permanent link">&para;</a></h2>
<p>Trong một lớp có thể tạo một số phương thức cùng tên nhưng khác nhau về danh sách tham số (khác nhau về số lượng tham số, kiểu dữ liệu của tham số, thứ tự các tham số). Cơ chế này gọi là nạp chồng phương thức.</p>
<p>Ví dụ:</p>
<pre><code class="language-c#">// Tạo lớp tĩnh chứa các hàm cùng tên tính tổng 
static class MyMath
{
    // Hàm tính tổng 2 số nguyên
    public static int Sum(int x, int y)
    { return x + y; }
    // Hàm tính tổng 3 số nguyên
    public static int Sum(int x, int y, int z)
    { return x + y + z; }
    // Hàm tính tổng 2 số thực
    public static double Sum(double x, double y) 
    {  return x + y; }
}

class Program
{
    public static void Main()
    {
        Console.WriteLine(MyMath.Sum(1, 2));
        Console.WriteLine(MyMath.Sum(1, 2, 3));
        Console.WriteLine(MyMath.Sum(2.34, 3.56 ));
    }
}
</code></pre>
<h2 id="nap-chong-toan-tu-operator-overloading">Nạp chồng toán tử (operator overloading)<a class="headerlink" href="#nap-chong-toan-tu-operator-overloading" title="Permanent link">&para;</a></h2>
<p>Các ngôn ngữ lập trình đều có sẵn các toán tử số học một ngôi, hai ngôi như: cộng, trừ, nhân, chia, so sánh, tăng giảm. Tuy nhiên, trong lập trình hướng đối tượng, các đối tượng do người dùng khai báo không thể sử dụng các toán tử trên một cách trực tiếp được (vì chúng thuộc kiểu dữ liệu tự định nghĩa).</p>
<p>C# cho phép nạp cài đặt lại (nạp chồng) một số toán tử đã được định nghĩa giúp cho các phép toán trên đối tượng trở nên quen thuộc hơn.</p>
<h3 id="cu-phap">Cú pháp<a class="headerlink" href="#cu-phap" title="Permanent link">&para;</a></h3>
<pre><code class="language-c#">public static &lt;T&gt; operator &lt;O&gt;(&lt;T&gt; [, &lt;T&gt;])
{
    // Các lệnh
    return &lt;T&gt;;
}
</code></pre>
<p>Trong đó <code>&lt;T&gt;</code> là tên kiểu dữ liệu tự định nghĩa (lớp/cấu trúc), <code>&lt;O&gt;</code> là toán tử nạp chồng được (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading#overloadable-operators">Xem danh sách toán tử có thể nạp chồng</a>.).</p>
<ul>
<li>Định nghĩa lại toán tử phải có các từ khóa <code>public static</code>.</li>
<li>Toán tử một ngôi có một tham số đầu vào, toán tử hai ngôi có hai tham số đầu vào. Ít nhất một toán tử phải cùng kiểu với kiểu trả về của phép toán.</li>
</ul>
<h3 id="vi-du">Ví dụ<a class="headerlink" href="#vi-du" title="Permanent link">&para;</a></h3>
<p>Đoạn code sau định nghĩa lại toán tử <code>+</code> thực hiện cộng hai phân số (<a href="https://github.com/nd-hung/oop/blob/main/docs/topics/classes-and-objects/code/OperatorOverloading/Program.cs">Xem mã nguồn đầy đủ trên GitHub</a>).</p>
<pre><code class="language-C#">public static PhanSo operator +(PhanSo a, PhanSo b)
{
    return new PhanSo(a.tuSo * b.mauSo + b.tuSo * a.mauSo, a.mauSo * b.mauSo);
}

// Chương trình chính
public static class TestOperatorOverloading
{
    public static void Main()
    {
        var a = new PhanSo(5, 4);
        var b = new PhanSo(1, 2);
        PhanSo c = a + b;   // c = 14 / 8
    }
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
